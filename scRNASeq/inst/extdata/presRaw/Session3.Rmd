---
title: "Single-cell RNA-seq ~ Session 3<html><div style='float:left'></div><hr color='#EB811B' size=1px width=796px></html>"
author: "Rockefeller University, Bioinformatics Resource Centre"
date: "http://rockefelleruniversity.github.io/RU_course_template/"
output: 
  xaringan::moon_reader:
    css: ["default", "metropolisCustom.css", "metropolis-fontsCustom.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
  html_document:
    toc: true # table of content true
    toc_float: yes
    depth: 3  # upto three depths of headings (specified by #, ## and ###)
    number_sections: false  ## if you want number sections at each table header
    theme: united  # many options for theme, this one is my favorite.
    highlight: tango  # specifies the syntax highlighting style
params:
  isSlides: "no"
---
```{r setup, include=FALSE}
suppressPackageStartupMessages(require(knitr))
suppressPackageStartupMessages(require(DropletUtils))
suppressPackageStartupMessages(require(DropletTestFiles))
suppressPackageStartupMessages(require(SingleCellExperiment))
suppressPackageStartupMessages(require(scran))
suppressPackageStartupMessages(require(scater))
suppressPackageStartupMessages(require(scuttle))
knitr::opts_chunk$set(echo = TRUE, tidy = T)
```

---
## Outline
There are more and more bioconductor packages supporting single-cell data analysis. R Amezquita, A Lun, S Hicks, and R Gottardo wrote an integrated workflow, [Orchestrating Single-Cell Analysis with Bioconductor](https://bioconductor.org/books/release/OSCA/), for single-cell data analysis and quality accessment. In this session, we will go through several important QC metrics which can't be made with Seurat. 

- how to differentiate empty droplets?
- how to estimate ambient RNA and remove them?
- how to identify doublets?
- any confounded effect?

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# load data and access empty drops

---
"    
  )
  
}

```

## Load data from Cell Ranger Result
```{r loadSCE,eval=FALSE,include=TRUE,echo=TRUE}
library(DropletUtils)
library(DropletTestFiles)
fname <- "file path to Cell Ranger results"
sce <- read10xCounts(fname, col.names=TRUE)
cellID <- colData(sce)$Barcode
cellID_sel <- sample(cellID,100000,replace = FALSE) # make subsets
sce_sub <- sce[,cellID_sel]
```
```{r loadSCE_io,include=TRUE,echo=FALSE,eval=TRUE}
sce_sub <- readRDS("data/scSeq_CTRL_sceSub.rds")
```

---
## SingleCellExperiment Object
```{r loadSCE_pres,include=TRUE,echo=TRUE,eval=TRUE}
sce_sub
# cell information
colData(sce_sub)[1:2,]
# gene information
rowData(sce_sub)[1:2,]
sce <- sce_sub
```

---
## Access UMI counts in each droplet
```{r rankUMI,eval=TRUE,}
bcrank <- barcodeRanks(counts(sce))
bcrank[1:2,]
```

---
## Knee plot
```{r rankUMI_knee,eval=FALSE,echo=TRUE,include=TRUE}
uniq <- !duplicated(bcrank$rank)
#
plot(bcrank$rank[uniq], bcrank$total[uniq], log="xy",
    xlab="Rank", ylab="Total UMI count", cex.lab=1.2)

abline(h=metadata(bcrank)$inflection, col="darkgreen", lty=2)
abline(h=metadata(bcrank)$knee, col="dodgerblue", lty=2)

legend("bottomleft", legend=c("Inflection", "Knee"), 
        col=c("darkgreen", "dodgerblue"), lty=2, cex=1.2)
```

---
## Knee Plot
```{r rankUMI_knee2,eval=TRUE,echo=FALSE,include=TRUE}
uniq <- !duplicated(bcrank$rank)
#
plot(bcrank$rank[uniq], bcrank$total[uniq], log="xy",
    xlab="Rank", ylab="Total UMI count", cex.lab=1.2)

abline(h=metadata(bcrank)$inflection, col="darkgreen", lty=2)
abline(h=metadata(bcrank)$knee, col="dodgerblue", lty=2)

legend("bottomleft", legend=c("Inflection", "Knee"), 
        col=c("darkgreen", "dodgerblue"), lty=2, cex=1.2)
```

---
## Identify non-empyt droplets
- limit: lowest counts per cell
- test.ambient: Could be used to estimate embient RNA contamination

```{r estDroplet,eval=TRUE,echo=TRUE,include=TRUE}
set.seed(100)
limit <- 100   
e.out <- emptyDrops(counts(sce),lower=limit, test.ambient=TRUE)
#
e.out
```

---
## Identify non-empty droplets
```{r estDroplet2,eval=TRUE,echo=TRUE,include=TRUE}
# Testeed by FDR
summary(e.out$FDR <= 0.001)
# Concordance by testing with FDR and limited
table(Sig=e.out$FDR <= 0.001, Limited=e.out$Limited)
```

---
## distribution of significance of non-empty reads
```{r estDroplet3,eval=TRUE,echo=TRUE,include=TRUE}
hist(e.out$PValue[e.out$Total <= limit & e.out$Total > 0],
    xlab="P-value", main="", col="grey80") 
```

---
## Subset non-empty droplets
```{r estDroplet4,eval=TRUE,echo=TRUE,include=TRUE}
sce2 <- sce[,which(e.out$FDR <= 0.001)]
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# Normalization and clustering

---
"    
  )
  
}
```

## Counts normalization
```{r countNorm,eval=TRUE,echo=TRUE,include=TRUE}
library(scran)
library(scuttle)
library(scater)
clusters <- quickCluster(sce2)
sce2 <- computeSumFactors(sce2, cluster=clusters)
sce2 <- logNormCounts(sce2)
sce2
```

---
## Identify variable features
```{r featureIdent,eval=TRUE,echo=TRUE,include=TRUE}
set.seed(1000)
# modeling variables
dec.pbmc <- modelGeneVarByPoisson(sce2)
# calcualte top features
top.pbmc <- getTopHVGs(dec.pbmc, prop=0.1)
```

---
## Make TSNE and UMAP plots
```{r plotUMAP,eval=TRUE,echo=TRUE,include=TRUE}
set.seed(1000)
# Evaluate PCs
sce2 <- denoisePCA(sce2, subset.row=top.pbmc, technical=dec.pbmc)
# make TSNE plot
sce2 <- runTSNE(sce2, dimred="PCA")
# make UMAP plot
sce2 <- runUMAP(sce2, dimred="PCA")
```

---
## Graphic based clustering
```{r clust,eval=TRUE,echo=TRUE,include=TRUE}
g <- buildSNNGraph(sce2, k=10, use.dimred = 'PCA')
clust <- igraph::cluster_walktrap(g)$membership
colLabels(sce2) <- factor(clust)
#
colData(sce2)
```

---
## UMAP plot
```{r plotUMAP_2,eval=TRUE,echo=TRUE,include=TRUE}
plotUMAP(sce2,colour_by="label")
```

---
## tSNE plot
```{r plotTSNE,eval=TRUE,echo=TRUE,include=TRUE}
plotTSNE(sce2,colour_by ="label")
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# Remove ambient RNA

---
"    
  )
  
}
```

## Abmient RNA
- cell-free RNAs contaminated in droplet
- could be estimated by empty droplets
```{r estAmb1,eval=TRUE,echo=TRUE,include=TRUE}
# extrat potential ambient RNA and thee estimated score
amb <- metadata(e.out)$ambient[,1]
head(amb)
```

---
## Remove ambient RNA
```{r estAmb2,eval=TRUE,echo=TRUE,include=TRUE}
library(scater)
stripped <- sce2[names(amb),]
out <- removeAmbience(counts(stripped), ambient=amb,groups = colLabels(stripped))
```

--
## Integrate corrected counts
```{r recalAmb,eval=TRUE,echo=TRUE,include=TRUE}
counts(stripped, withDimnames=FALSE) <- out
stripped <- logNormCounts(stripped)
```

---
## Before/After removement
- Hemoglobin A1 (Hba-a1) as example
- in most cases the Hbs are contaminated from residual RBCs
```{r compRMAmb,eval=FALSE,echo=TRUE,include=TRUE}
ensmbl_id <- rowData(sce2)$ID[rowData(sce2)$Symbol=="Hba-a1"]
plotExpression(sce2, x="label", colour_by="label", features=ensmbl_id) + 
        ggtitle("Before")
plotExpression(stripped, x="label", colour_by="label", features=ensmbl_id) + 
        ggtitle("After")
```

---
## Before/After removement
- Hemoglobin A1 (Hba-a1) as example
- in most cases the Hbs are contaminated from residual RBCs
```{r compRMAmb_pres,eval=TRUE,echo=FALSE,include=TRUE}
plotExpression(sce2, x="label", colour_by="label", features=ensmbl_id) + 
        ggtitle("Before")
plotExpression(stripped, x="label", colour_by="label", features=ensmbl_id) + 
        ggtitle("After")
```

---
## Before/After removement
- Krt17 as example
```{r compRMAmb2,eval=FALSE,echo=TRUE,include=TRUE}
ensmbl_id <- rowData(sce2)$ID[rowData(sce2)$Symbol=="Krt17"]
plotExpression(sce2, x="label", colour_by="label", features=ensmbl_id) + 
        ggtitle("Before")
plotExpression(stripped, x="label", colour_by="label", features=ensmbl_id) + 
        ggtitle("After")
```

---
## Before/After removement
- Krt17 as example
```{r compRMAmb2_pres,eval=TRUE,echo=FALSE,include=TRUE}
plotExpression(sce2, x="label", colour_by="label", features=ensmbl_id) + 
        ggtitle("Before")
plotExpression(stripped, x="label", colour_by="label", features=ensmbl_id) + 
        ggtitle("After")
```

---
## Save result
```{r rmAmb_store,eval=TRUE,echo=TRUE,include=TRUE}
saveRDS(stripped,"scSeq_CTRL_sceSub_rmAmbRNA.rds")
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# Remove doublets

---
"    
  )
  
}
```

---
## Doublets
- Doublets means two or more cells clumped in a single droplet. Thus, the read counts and genes detected in this droplet would be much higher than other droplets.
- here, we demonstrate how to identify doublets by silmulation with [scran](https://bioconductor.org/packages/release/bioc/manuals/scran/man/scran.pdf)

---
## Normalization and clustering
```{r normClust,eval=FALSE,echo=TRUE,include=TRUE}
dec <- modelGeneVar(stripped)
hvgs <- getTopHVGs(dec,n=1000)
stripped <- runPCA(stripped, ncomponents=10, subset_row=hvgs)
stripped <- runUMAP(stripped, dimred="PCA")
g <- buildSNNGraph(stripped, k=10, use.dimred = 'PCA')
clust <- igraph::cluster_walktrap(g)$membership
colLabels(stripped) <- factor(clust)
plotUMAP(stripped,colour_by="label")
```

---
## Normalization and clustering
```{r normClust2,eval=TRUE,echo=FALSE,include=TRUE}
dec <- modelGeneVar(stripped)
hvgs <- getTopHVGs(dec,n=1000)
stripped <- runPCA(stripped, ncomponents=10, subset_row=hvgs)
stripped <- runUMAP(stripped, dimred="PCA")
g <- buildSNNGraph(stripped, k=10, use.dimred = 'PCA')
clust <- igraph::cluster_walktrap(g)$membership
colLabels(stripped) <- factor(clust)
plotUMAP(stripped,colour_by="label")
```

---
## Estimate doublets
```{r estDoublet,eval=TRUE,echo=TRUE,include=TRUE}
dbl.dens <- computeDoubletDensity(stripped, #subset.row=top.mam, 
    d=ncol(reducedDim(stripped)),subset.row=hvgs)
summary(dbl.dens)
stripped$DoubletScore <- dbl.dens
```

---
## Plot doublets scores ~ UMAP
```{r doublerScore,eval=TRUE,echo=TRUE,include=TRUE}
plotUMAP(stripped,colour_by="DoubletScore")
```

---
## Plot doublets scores by cluster
```{r doublerScorebyClust,eval=TRUE,echo=TRUE,include=TRUE}
plotColData(stripped, x="label", y="DoubletScore", colour_by="label")+
  geom_hline(yintercept = quantile(colData(stripped)$DoubletScore,0.95),lty="dashed",color="red")
```
- No clusters have significantly higher doublet scores than other clusters.No clusters would be removed.
- Red dash line representd 95% quantile of doublet score. The cells with higher doublrt score than this cut-off would be removed.

---
## Remove doublets
```{r rmDoublet,eval=TRUE,echo=TRUE,include=TRUE}
cut_off <- quantile(stripped$DoubletScore,0.95)
stripped$isDoublet <- c("no","yes")[factor(as.integer(stripped$DoubletScore>=cut_off),levels=c(0,1))]
table(stripped$isDoublet)
sce_clean <- stripped[stripped$isDoublet=="no",]
saveRDS(sce_clean,"scSeq_CTRL_sceSub_rmAmbRNA_rmDoublet.rds")
```

---
```{r, results='asis',include=TRUE,echo=FALSE}
if(params$isSlides != "yes"){
  cat("# QC plots after cleanrance

---
"    
  )
  
}
```

## QC plots
- mitochondrial content
- Genes detected
- Reads per cell
```{r evaQC_cal,eval=TRUE,echo=TRUE,include=TRUE}
library(scater)
sce_clean <- sce_clean2 
mtGene <- rowData(sce_clean)$ID[grepl(rowData(sce_clean)$Symbol,pattern = "mt-")]
is.mito<- names(sce_clean) %in% mtGene
sce_clean <- addPerCellQC(sce_clean, subsets=list(Mito=is.mito))
```

---
## QC plots 
- violin plot of read counts, gene counts, and mitochondrial contents per cell
```{r qc_mrg,eval=TRUE,echo=TRUE,include=TRUE}
plotColData(sce_clean,x="label", y="sum", colour_by="label")+ggtitle("read counts")
plotColData(sce_clean,x="label", y="detected", colour_by="label")+ggtitle("gene counts")
plotColData(sce_clean,x="label", y="subsets_Mito_percent", colour_by="label")+ggtitle("mitocondrial content")
```

---
## QC plots ~ comparison
- mitochondrial contents vs read counts
- gene counts vs read counts
```{r qc_complex,eval=TRUE,echo=TRUE,include=TRUE}
plotColData(sce_clean,x="sum",y="subsets_Mito_percent",colour_by="label")+ggtitle("is.mito vs read counts")
plotColData(sce_clean,x="sum",y="detected",colour_by="label")+ggtitle("gene counts vs read counts")
```

---
## Estimate variance explaination
- clustering (leable), mitochindrial content (subsets_Mito_percent), doublets (DoubletScore), read counts (sum), and gene counts (detected) were tested.
- We would suppose "label" (clustering) would explain more variances than other controls.
```{r varExp,eval=TRUE,echo=TRUE,include=TRUE}
vars <- getVarianceExplained(sce_clean, 
    variables=c("DoubletScore","label","sum","detected","subsets_Mito_percent"))
plotExplanatoryVariables(vars)
```

---
## Exercise Time
- [Exercise]()
- [Answer]()