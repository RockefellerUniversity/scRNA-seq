<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Single-cell RNA sequencing ~ Session 2    </title>
    <meta charset="utf-8" />
    <meta name="author" content="Rockefeller University, Bioinformatics Resource Centre" />
    <script src="libs/header-attrs-2.27/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="metropolisCustom.css" type="text/css" />
    <link rel="stylesheet" href="metropolis-fontsCustom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# Single-cell RNA sequencing ~ Session 2<br />
<html><br />
<br />
<hr color='#EB811B' size=1px width=796px><br />
</html>
]
.author[
### Rockefeller University, Bioinformatics Resource Centre
]
.date[
### <a href="http://rockefelleruniversity.github.io/scRNA-seq/" class="uri">http://rockefelleruniversity.github.io/scRNA-seq/</a>
]

---




## Overview

In this course we are going to introduce basic analysis for single-cell RNAseq, with a specific focus on the *10X system*. The course is divided into multiple sessions. 

In this second session, we will introduce Seurat and Bioconductor methodologies for basic scRNA-seq QC, filtering and initial analysis of single samples.
---
## The data

For these sessions we are going to make use of two datasets.

The first set will be from the recent paper [**Enteroendocrine cell lineages that differentially control feeding and gut motility**](https://elifesciences.org/articles/78512).  
This contains scRNA data from either Neurod1 and Neurog3 expressing enteroendocrine cells.

The second dataset is the classic example from PBMC cells.

---
## Seurat and Bioconductor

The Seurat R package and associated packages offer an R based and well established methodology for the analysis of single cell RNA-seq, ATAC-seq and many other single-cell sequencing methodologies.

Bioconductor has a set of interrelated and highly connected software packages for single cell RNAseq as well as integrating with the rest of the Bioconductor software ecosystem.

In this session we will run through basic analyses using both of the methodologies to show both their equvalence in some parts of the analysis as well as their distinct functionalities in others.

In practice, you may select methods from either softwares and convert between the two as required.

---
# The Example Data

For this session we will need the filtered and raw expression data for the Neurod1 datasets.

The filtered matrix can be found [here](https://rubioinformatics.s3.amazonaws.com/scRNA_graduate/SRR_NeuroD1/outs/NeuroD1_filtered_feature_bc_matrix.h5)

The raw matrix can be found here [here](https://rubioinformatics.s3.amazonaws.com/scRNA_graduate/SRR_NeuroD1/outs/filtered_feature_bc_matrix.h5)


class: inverse, center, middle

# Cell Ranger -  Output files

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

---
# Data import (Bioconductor) 

First we need to load the DropletUtils package to read and handle our Droplet 10X data.


``` r
library(DropletUtils)
```

```
## Warning: package 'DropletUtils' was built under R version 4.4.1
```

```
## Loading required package: SingleCellExperiment
```

```
## Warning: package 'SingleCellExperiment' was built under R version 4.4.1
```

```
## Loading required package: SummarizedExperiment
```

```
## Warning: package 'SummarizedExperiment' was built under R version 4.4.1
```

```
## Loading required package: MatrixGenerics
```

```
## Warning: package 'MatrixGenerics' was built under R version 4.4.1
```

```
## Loading required package: matrixStats
```

```
## 
## Attaching package: 'MatrixGenerics'
```

```
## The following objects are masked from 'package:matrixStats':
## 
##     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse,
##     colCounts, colCummaxs, colCummins, colCumprods, colCumsums,
##     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs,
##     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats,
##     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds,
##     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads,
##     colWeightedMeans, colWeightedMedians, colWeightedSds,
##     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet,
##     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods,
##     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps,
##     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins,
##     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks,
##     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars,
##     rowWeightedMads, rowWeightedMeans, rowWeightedMedians,
##     rowWeightedSds, rowWeightedVars
```

```
## Loading required package: GenomicRanges
```

```
## Warning: package 'GenomicRanges' was built under R version 4.4.1
```

```
## Loading required package: GenomeInfoDb
```

```
## Warning: package 'GenomeInfoDb' was built under R version 4.4.1
```

```
## 
## Attaching package: 'GenomicRanges'
```

```
## The following object is masked from 'package:magrittr':
## 
##     subtract
```

```
## Loading required package: Biobase
```

```
## Warning: package 'Biobase' was built under R version 4.4.1
```

```
## Welcome to Bioconductor
## 
##     Vignettes contain introductory material; view with
##     'browseVignettes()'. To cite Bioconductor, see
##     'citation("Biobase")', and for packages 'citation("pkgname")'.
```

```
## 
## Attaching package: 'Biobase'
```

```
## The following object is masked from 'package:MatrixGenerics':
## 
##     rowMedians
```

```
## The following objects are masked from 'package:matrixStats':
## 
##     anyMissing, rowMedians
```

---
# Read10x

We can then read in the filtered matrix containing data on droplets marked as cells by CellRanger.


``` r
h5file &lt;- "https://rubioinformatics.s3.amazonaws.com/scRNA_graduate/SRR_NeuroD1/outs/NeuroD1_filtered_feature_bc_matrix.h5"
local_h5file &lt;- basename(h5file)
download.file(h5file, local_h5file)

sce.NeuroD1_filtered &lt;- read10xCounts(local_h5file, col.names = TRUE)

class(sce.NeuroD1_filtered)
```

```
## [1] "SingleCellExperiment"
## attr(,"package")
## [1] "SingleCellExperiment"
```



---

## SingleCellExperiment Object
The created SingleCellExperiment Object is much like our SummarizedExperiment object


``` r
sce.NeuroD1_filtered
```

```
## class: SingleCellExperiment 
## dim: 55417 3265 
## metadata(1): Samples
## assays(1): counts
## rownames(55417): ENSMUSG00000102628 ENSMUSG00000100595 ...
##   ENSMUSG00000095742 TMT
## rowData names(3): ID Symbol Type
## colnames(3265): AAACCCACACAATGTC-1 AAACCCACACCACTGG-1 ...
##   TTTGTTGTCTCTTAAC-1 TTTGTTGTCTGGACCG-1
## colData names(2): Sample Barcode
## reducedDimNames(0):
## mainExpName: NULL
## altExpNames(0):
```

---

## SingleCellExperiment Object
The *colnames()* and *rownames()* functions can be used to access column names (cell-barcodes) and row names (gene identifiers)


``` r
# cell information
colnames(sce.NeuroD1_filtered)[1:2]
```

```
## [1] "AAACCCACACAATGTC-1" "AAACCCACACCACTGG-1"
```

``` r
# gene information
rownames(sce.NeuroD1_filtered)[1:2]
```

```
## [1] "ENSMUSG00000102628" "ENSMUSG00000100595"
```

## SingleCellExperiment Object
The *colData()* and *rowData()* functions can be used to access experiment metadata. 


``` r
# cell information
colData(sce.NeuroD1_filtered)[1:2, ]
```

```
## DataFrame with 2 rows and 2 columns
##                                    Sample            Barcode
##                               &lt;character&gt;        &lt;character&gt;
## AAACCCACACAATGTC-1 NeuroD1_filtered_fea.. AAACCCACACAATGTC-1
## AAACCCACACCACTGG-1 NeuroD1_filtered_fea.. AAACCCACACCACTGG-1
```

``` r
# gene information
rowData(sce.NeuroD1_filtered)[1:2, ]
```

```
## DataFrame with 2 rows and 3 columns
##                                    ID      Symbol            Type
##                           &lt;character&gt; &lt;character&gt;     &lt;character&gt;
## ENSMUSG00000102628 ENSMUSG00000102628     Gm37671 Gene Expression
## ENSMUSG00000100595 ENSMUSG00000100595     Gm19087 Gene Expression
```

## SingleCellExperiment Object

A reducedDim and reducedDimNames slots at present remains unfilled.

The metadata slot contains the Sample names. Here all these cells came from single sample


``` r
# cell information
reducedDimNames(sce.NeuroD1_filtered)
```

```
## character(0)
```

``` r
# gene information
metadata(sce.NeuroD1_filtered)
```

```
## $Samples
## [1] "NeuroD1_filtered_feature_bc_matrix.h5"
```


---
## The knee plot

One of the first plots we may want to recreate from the QC is the knee plot.

To do this we will need the unfiltered matrix too. 

The unfiltered SingleCellExperiment contains over a million droplets.



``` r
h5file &lt;- "https://rubioinformatics.s3.amazonaws.com/scRNA_graduate/SRR_NeuroD1/outs/raw_feature_bc_matrix.h5"
local_h5file &lt;- "NeuroD1_raw_feature_bc_matrix.h5"
download.file(h5file, local_h5file)
sce.NeuroD1_unfiltered &lt;- read10xCounts(local_h5file, col.names = TRUE)
sce.NeuroD1_unfiltered
```

```
## class: SingleCellExperiment 
## dim: 39457 1244317 
## metadata(1): Samples
## assays(1): counts
## rownames(39457): Gm26206 Xkr4 ... LOC118568478 LOC118568479
## rowData names(3): ID Symbol Type
## colnames(1244317): AAACCCAAGAAACACT-1 AAACCCAAGAAACCAT-1 ...
##   TTTGTTGTCTTTGCTA-1 TTTGTTGTCTTTGTCG-1
## colData names(2): Sample Barcode
## reducedDimNames(0):
## mainExpName: NULL
## altExpNames(0):
```



---
## Barcode ranks




``` r
bcrank &lt;- barcodeRanks(counts(sce.NeuroD1_unfiltered))
bcrank
```

```
## DataFrame with 1244317 rows and 3 columns
##                         rank     total    fitted
##                    &lt;numeric&gt; &lt;integer&gt; &lt;numeric&gt;
## AAACCCAAGAAACACT-1     55172       118        NA
## AAACCCAAGAAACCAT-1    167382         2        NA
## AAACCCAAGAAACCCG-1    993508         0        NA
## AAACCCAAGAAACCTG-1    993508         0        NA
## AAACCCAAGAAAGAAC-1    993508         0        NA
## ...                      ...       ...       ...
## TTTGTTGTCTTTGATC-1   31532.5       146        NA
## TTTGTTGTCTTTGCAT-1  480107.0         1        NA
## TTTGTTGTCTTTGCGC-1  480107.0         1        NA
## TTTGTTGTCTTTGCTA-1  480107.0         1        NA
## TTTGTTGTCTTTGTCG-1  480107.0         1        NA
```

---
## Retrieve filtered barcodes


``` r
bcrank$filtered &lt;- rownames(bcrank) %in% colnames(sce.NeuroD1_filtered)
bc_plot &lt;- as.data.frame(bcrank)
bc_plot &lt;- bc_plot[order(bc_plot$filtered, decreasing = TRUE), ]
bc_plot &lt;- bc_plot[!duplicated(bc_plot$rank), ]
```

---
## Plotting barcode rank


``` r
require(ggplot2)
```

```
## Loading required package: ggplot2
```

``` r
ggplot(bc_plot, aes(x = rank, y = total, colour = filtered, alpha = 0.001)) + geom_point() +
    scale_y_log10() + scale_x_log10() + theme_minimal() + geom_hline(yintercept = metadata(bcrank)$inflection,
    colour = "darkgreen", linetype = 2) + geom_hline(yintercept = metadata(bcrank)$knee,
    colour = "dodgerblue", linetype = 2)
```

```
## Warning in scale_y_log10(): log-10 transformation introduced infinite values.
```

![](Session2_files/figure-html/unnamed-chunk-10-1.png)&lt;!-- --&gt;

---
## Filtering droplets using Droplet utils

Although CellRanger provides a filtered Droplet matrix, you may wish to provide your own cut-off based on knee plots generated and/or use the emptyDrops method in Droplet utils to identify cell containing droplets.


``` r
e.out &lt;- emptyDrops(counts(sce.NeuroD1_unfiltered))
table(e.out)
head(e.out)
```






class: inverse, center, middle

# Bioconductor  -  QC

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

## Working with CellRanger filtered matrix

From this point we will use the Droplets filtered using Cellranger


``` r
sce.NeuroD1_filtered
```

```
## class: SingleCellExperiment 
## dim: 55417 3265 
## metadata(1): Samples
## assays(1): counts
## rownames(55417): ENSMUSG00000102628 ENSMUSG00000100595 ...
##   ENSMUSG00000095742 TMT
## rowData names(3): ID Symbol Type
## colnames(3265): AAACCCACACAATGTC-1 AAACCCACACCACTGG-1 ...
##   TTTGTTGTCTCTTAAC-1 TTTGTTGTCTGGACCG-1
## colData names(2): Sample Barcode
## reducedDimNames(0):
## mainExpName: NULL
## altExpNames(0):
```
  
---
## Add QC metrics

To assess QC we first want to identify mitochondrial and ribosomal genes.

High mitochondrial gene expression within a cell is often used as a marker of dying cells.


``` r
is.mito &lt;- grepl("^mt", rowData(sce.NeuroD1_filtered)$Symbol)
is.ribo &lt;- grepl("^Rps", rowData(sce.NeuroD1_filtered)$Symbol)

table(is.mito)
```

```
## is.mito
## FALSE  TRUE 
## 55380    37
```

``` r
table(is.ribo)
```

```
## is.ribo
## FALSE  TRUE 
## 55246   171
```
  
---
## Add QC metrics

The scuttle package has functions for normalisation, transformation and QC.

Here we us the addPerCellQCMetrics function to update our SingleCellExperiment object with QC information.


``` r
library(scuttle)
```

```
## Warning: package 'scuttle' was built under R version 4.4.1
```

``` r
sce.NeuroD1_filtered &lt;- addPerCellQCMetrics(sce.NeuroD1_filtered, subsets = list(Mito = is.mito,
    Ribosomal = is.ribo))
sce.NeuroD1_filtered
```

```
## class: SingleCellExperiment 
## dim: 55417 3265 
## metadata(1): Samples
## assays(1): counts
## rownames(55417): ENSMUSG00000102628 ENSMUSG00000100595 ...
##   ENSMUSG00000095742 TMT
## rowData names(3): ID Symbol Type
## colnames(3265): AAACCCACACAATGTC-1 AAACCCACACCACTGG-1 ...
##   TTTGTTGTCTCTTAAC-1 TTTGTTGTCTGGACCG-1
## colData names(11): Sample Barcode ... subsets_Ribosomal_percent total
## reducedDimNames(0):
## mainExpName: NULL
## altExpNames(0):
```

---
## QC in colData

The QC data per Droplet has been added to additional columns in the colData slot of our SingleCellExperiment.


``` r
qc_df &lt;- colData(sce.NeuroD1_filtered)
head(qc_df, n = 2)
```

```
## DataFrame with 2 rows and 11 columns
##                                    Sample            Barcode       sum
##                               &lt;character&gt;        &lt;character&gt; &lt;numeric&gt;
## AAACCCACACAATGTC-1 NeuroD1_filtered_fea.. AAACCCACACAATGTC-1     28295
## AAACCCACACCACTGG-1 NeuroD1_filtered_fea.. AAACCCACACCACTGG-1      1498
##                     detected subsets_Mito_sum subsets_Mito_detected
##                    &lt;integer&gt;        &lt;numeric&gt;             &lt;integer&gt;
## AAACCCACACAATGTC-1      5892             1862                    16
## AAACCCACACCACTGG-1       245             1011                    13
##                    subsets_Mito_percent subsets_Ribosomal_sum
##                               &lt;numeric&gt;             &lt;numeric&gt;
## AAACCCACACAATGTC-1              6.58067                   256
## AAACCCACACCACTGG-1             67.48999                     4
##                    subsets_Ribosomal_detected subsets_Ribosomal_percent
##                                     &lt;integer&gt;                 &lt;numeric&gt;
## AAACCCACACAATGTC-1                         39                  0.904753
## AAACCCACACCACTGG-1                          4                  0.267023
##                        total
##                    &lt;numeric&gt;
## AAACCCACACAATGTC-1     28295
## AAACCCACACCACTGG-1      1498
```


---
## Plotting QC data

We can then plot this using the plotColData function from the Scater package.

First we plot the distritbution of total reads per cell.


``` r
library(scater)
```

```
## Warning: package 'scater' was built under R version 4.4.1
```

``` r
plotColData(sce.NeuroD1_filtered, x = "Sample", y = "sum")
```

![](Session2_files/figure-html/unnamed-chunk-19-1.png)&lt;!-- --&gt;

---
## Plotting QC data

Then we plot the distritbution of total detected genes per cell.


``` r
library(scater)
plotColData(sce.NeuroD1_filtered, x = "Sample", y = "detected")
```

![](Session2_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

---
## Plotting QC data

Then we plot the distritbution of percent of mitochondrial and ribosomal reads per cell.


``` r
library(scater)
p1 &lt;- plotColData(sce.NeuroD1_filtered, x = "Sample", y = "subsets_Mito_percent")
p2 &lt;- plotColData(sce.NeuroD1_filtered, x = "Sample", y = "subsets_Ribosomal_percent")
gridExtra::grid.arrange(p1, p2, ncol = 2)
```

![](Session2_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;

---
## Plotting QC data

It also can be useful to capture the QC columns against each other as scatterplots


``` r
library(scater)
p1 &lt;- plotColData(sce.NeuroD1_filtered, x = "sum", y = "detected")
p2 &lt;- plotColData(sce.NeuroD1_filtered, x = "sum", y = "subsets_Mito_percent")
p3 &lt;- plotColData(sce.NeuroD1_filtered, x = "detected", y = "subsets_Mito_percent")
gridExtra::grid.arrange(p1, p2, p3, ncol = 3)
```

![](Session2_files/figure-html/unnamed-chunk-22-1.png)&lt;!-- --&gt;

---
## Removing low quality data

At this point we may want to remove low quality data.

Typically droplet filters on mitochondrial read content, total detect genes and total read counts are applied.


``` r
qc.high_lib_size &lt;- colData(sce.NeuroD1_filtered)$sum &gt; 125000
qc.min_detected &lt;- colData(sce.NeuroD1_filtered)$detected &lt; 200
qc.mito &lt;- colData(sce.NeuroD1_filtered)$subsets_Mito_percent &gt; 25
discard &lt;- qc.high_lib_size | qc.mito | qc.min_detected
DataFrame(LibSize = sum(qc.high_lib_size), Detected = sum(qc.min_detected), MitoProp = sum(qc.mito),
    Total = sum(discard))
```

```
## DataFrame with 1 row and 4 columns
##     LibSize  Detected  MitoProp     Total
##   &lt;integer&gt; &lt;integer&gt; &lt;integer&gt; &lt;integer&gt;
## 1        17       243      1076      1104
```

---
## Removing low quality data

We will add this back in the colData slot to perform some final QC plots before filtering


``` r
colData(sce.NeuroD1_filtered) &lt;- cbind(colData(sce.NeuroD1_filtered), DataFrame(toDiscard = discard))
p1 &lt;- plotColData(sce.NeuroD1_filtered, x = "sum", y = "detected", colour_by = "toDiscard")
p2 &lt;- plotColData(sce.NeuroD1_filtered, x = "sum", y = "subsets_Mito_percent", colour_by = "toDiscard")
p3 &lt;- plotColData(sce.NeuroD1_filtered, x = "detected", y = "subsets_Mito_percent",
    colour_by = "toDiscard")
gridExtra::grid.arrange(p1, p2, p3, ncol = 3)
```

![](Session2_files/figure-html/unnamed-chunk-24-1.png)&lt;!-- --&gt;

---
## Removing low quality data


``` r
sce.NeuroD1_filtered_QCed &lt;- sce.NeuroD1_filtered[, sce.NeuroD1_filtered$toDiscard %in%
    "FALSE"]
sce.NeuroD1_filtered_QCed
```

```
## class: SingleCellExperiment 
## dim: 55417 2161 
## metadata(1): Samples
## assays(1): counts
## rownames(55417): ENSMUSG00000102628 ENSMUSG00000100595 ...
##   ENSMUSG00000095742 TMT
## rowData names(3): ID Symbol Type
## colnames(2161): AAACCCACACAATGTC-1 AAACCCACACGAGAAC-1 ...
##   TTTGGAGTCCGTAGGC-1 TTTGTTGGTCTAACTG-1
## colData names(12): Sample Barcode ... total toDiscard
## reducedDimNames(0):
## mainExpName: NULL
## altExpNames(0):
```

---

class: inverse, center, middle

# Bioconductor  -  Normalisation and Clustering

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=720px&gt;&lt;/html&gt; 

---

---
# Log Normalisation



``` r
sce.NeuroD1_filtered_QCed &lt;- logNormCounts(sce.NeuroD1_filtered_QCed)
assayNames(sce.NeuroD1_filtered_QCed)
```

```
## [1] "counts"    "logcounts"
```

---
## Log Normalisation



``` r
sce.NeuroD1_filtered_QCed &lt;- logNormCounts(sce.NeuroD1_filtered_QCed)
assayNames(sce.NeuroD1_filtered_QCed)
```

```
## [1] "counts"    "logcounts"
```

---
## Log Normalisation accounting for differing cell populations



``` r
library(scran)
```

```
## Warning: package 'scran' was built under R version 4.4.1
```

``` r
clust.sce.NeuroD1_filtered_QCed &lt;- quickCluster(sce.NeuroD1_filtered_QCed)
sce.NeuroD1_filtered_trimmed &lt;- computeSumFactors(sce.NeuroD1_filtered_QCed, cluster = clust.sce.NeuroD1_filtered_QCed)
sce.NeuroD1_filtered_QCed &lt;- logNormCounts(sce.NeuroD1_filtered_QCed)
assayNames(sce.NeuroD1_filtered_QCed)
```

```
## [1] "counts"    "logcounts"
```

---
## Modeling the mean-variance relationship


``` r
##
dec.NeuroD1_filtered_QCed &lt;- modelGeneVar(sce.NeuroD1_filtered_QCed)
ggplot(dec.NeuroD1_filtered_QCed, aes(x = mean, y = total)) + geom_point()
```

![](Session2_files/figure-html/unnamed-chunk-30-1.png)&lt;!-- --&gt;

---
## Identifying top variable genes for PCA


``` r
top.NeuroD1_filtered_QCed &lt;- getTopHVGs(dec.NeuroD1_filtered_QCed, n = 3000)
```

---
## PCA


``` r
set.seed(100)  # See below.
sce.NeuroD1_filtered_QCed &lt;- fixedPCA(sce.NeuroD1_filtered_QCed, subset.row = top.NeuroD1_filtered_QCed)
reducedDimNames(sce.NeuroD1_filtered_QCed)
```

```
## [1] "PCA"
```

---
## PCA


``` r
plotReducedDim(sce.NeuroD1_filtered_QCed, dimred = "PCA", colour_by = "subsets_Mito_percent")
```

![](Session2_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

---
## Select PCs from PCA


``` r
percent.var &lt;- attr(reducedDim(sce.NeuroD1_filtered_QCed), "percentVar")
plot(percent.var, log = "y", xlab = "PC", ylab = "Variance explained (%)")
```

![](Session2_files/figure-html/unnamed-chunk-34-1.png)&lt;!-- --&gt;

``` r
# library(PCAtools) chosen.elbow &lt;- findElbowPoint(percent.var)
```


---
## Visualise in 2D with Tisne and UMAP


``` r
sce.NeuroD1_filtered_QCed &lt;- runTSNE(sce.NeuroD1_filtered_QCed, n_dimred = 30)
sce.NeuroD1_filtered_QCed &lt;- runUMAP(sce.NeuroD1_filtered_QCed, n_dimred = 30)
reducedDimNames(sce.NeuroD1_filtered_QCed)
```

```
## [1] "PCA"  "TSNE" "UMAP"
```

---
## Visualise in 2D with Tisne and UMAP


``` r
plotUMAP(sce.NeuroD1_filtered_QCed, colour_by = "subsets_Mito_percent")
```

![](Session2_files/figure-html/unnamed-chunk-36-1.png)&lt;!-- --&gt;

``` r
plotTSNE(sce.NeuroD1_filtered_QCed, colour_by = "subsets_Mito_percent")
```

![](Session2_files/figure-html/unnamed-chunk-36-2.png)&lt;!-- --&gt;

## Clustering


&lt;!-- --- --&gt;
&lt;!-- ## Select PCs from PCA --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- # set.seed(1000) --&gt;
&lt;!-- # # Evaluate PCs --&gt;
&lt;!-- # sce.NeuroD1_filtered_QCed &lt;- denoisePCA(sce.NeuroD1_filtered_QCed, subset.row = top.NeuroD1_filtered_QCed, technical = dec.NeuroD1_filtered_QCed) --&gt;
&lt;!-- # ncol(reducedDim(sce.NeuroD1_filtered_QCed)) --&gt;

&lt;!-- ``` --&gt;



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
